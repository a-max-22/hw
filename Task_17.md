
### Вариант 1
В данном варианте предлагаю изменения, которые не изменяют напрямую текущую функциональность, однако, на мой взгляд, могут в целом  повысить выразительность кода, а также его тестируемость и поддерживаемость. 

Проект, в который вносятся изменения, представляет собой драйвер, одна из функций которого - отправка и получение буферов данных к/от оборудования.  Формат данных данных и протокол их  передачи  зависит от кода операции ввода/вывода (IRP). По итогу получается, что код, который отвечает за обработку запросов каждого типа, распределен между процедурами: 
1) приема запроса от клиента (на этом этапе происходит  валидация входных данных)
2) записи данных на устройство (на этом этапе происходит правильная "упаковка" данных в соответствии с нужным форматом)
3) обработки прерываний (на этом этапе ставится в очередь выполнения соответствующая процедура, которая выполняет считывание данных с устройства)
4) процедура, которая выполняет считывание данных с устройства (считывает данные в правильной последовательности и соответствующем формате)
Таким образом, видится разумным изменить перечисленные функции, введя сущность, которая характеризует текущий сеанс обмена данными между устройством и хостом, которую можно обозначить как "транзакция", или "сеанс". Полагаю, что "сеанс" будет более удачным термином, так как транзакция предполагает такие свойства (возможность отменить, откатить изменения, например), которые не предполагаются в текущей реализации. 

В результате мы таким образом вводим некий абстрактный тип данных, представленный структурой (т.к. драйвер реализован на С), который в виде функций обратного вызова (аналог методов по сути) содержит в себе все необходимые функции для его обработки на каждом из этапов, наряду со всем необходимым контекстом. Это также упрощает внедрение новых форматов обмена данными,  а также тестирование указанного кода. 

### Вариант 2
В данном варианте изменения связаны с внедрением новой функциональности. 

Проект представляет собой компонент, который предназначен для анализа двоичного скомпилированного кода.  Кратко его архитектуру можно представить как функцию обхода графа базовых блоков, которая вызывает те или иные обработчики, в случае, если найдены те или иные инструкции или паттерны.  В данных обработчиках предусмотрен код, который эмулирует те или иные инструкции, в зависимости от заданных критериев (адрес перехода, аргумент инструкции, и.т.д. ). Эмуляция происходит строго синхронно. С учетом того, что это достаточно затратный по времени процесс, это блокирует выполнение других обработчиков, значительно замедляя тем самым общее время обхода графа. 

Таким образом, естественным развитием данного функционала видится добавление возможности выполнять те или  иные операции асинхронно (как например ту же эмуляцию). Это влечет за собой необходимость реализации: 
1) очереди базовых блоков, находящихся в обработке
2) механизма независимого выполнения задач несколькими обработчиками 
Сама эмуляция таким образом может быть реализована в отдельном потоке, процессе, на отельном сервере, обработчик будет получать итоговый результат. Усложнится также механизм внесения изменений инструкции, так как надо будет ждать завершения всех обработчиков. Таким образом, при необходимости изменений, здесь возможно либо создание блоков заново, либо создание структуры, которая хранит в себе список изменений для их дальнейшего применения.  
Кажется, что  для реализации подобного функционала очень подходит декларативная конкурентная парадигма с механизмом отложенного связывания переменной. 

### Выводы

Данное задание показалось довольно сложным. Выходить за рамки локальных изменений лично для меня всегда непросто, наверное поэтому описание варианта 2 кажется таким размытым. При этом определенный прогресс видится, так как еще некоторое время назад я наверное и не подступился бы к этой задаче.  Хотелось бы отметить,  что как минимум в данном конкретном задании  базис в виде знания о вычислительных моделях, а также о том, что такое АТД позволяет лучше структурировать и яснее представлять будущие изменения. 
Интересно будет  вернуться к этому через некоторое время. 
