Так получилось, что с фаззерами я знаком достаточно давно. Активно применял различные вариации afl-подобных фаззеров для тестирования различных программ. Разрабатывал свой фаззер подобного рода, в качестве тренировочного проекта, а также  потому что код afl++ казался мне чрезмерно запутанным. 

В текущем задании для меня наиболее актуальным было применение  фазз-тестирования для драйвера под ОС Windows, общий объем которого составляет около 2 тыс. строк кода, язык разработки - C. Для решения данной задачи применил хорошо известный инструмент - https://github.com/Cr4sh/ioctlfuzzer + написал свою дополнительную обертку, которая хаотично делает запросы к драйверу со случайными параметрами. Проверял таким образом его "устойчивость". 

В развертыванием инструмента как таковых сложностей не было, возможно потому что уже есть некоторая привычка к тому, что любой инструмент подобного рода работает не сразу и приходится прилагать дополнительные усилия, чтобы заставить его функционировать в своей среде. 

Такое тестирование хорошо выявляет те случаи, когда ты забываешь делать ту или иную валидацию недоверенных пользовательских данных, которые поступают из user-mode (размеры буфера, отношения между полями тех или иных структур). Сейчас сложно оценить общий объем ошибок, которые были найдены таким образом, однако в среднем их количество составляло порядка 1-2 падений на каждый добавленный код ioctl (в зависимости от сложности формата входного буфера). Принимая во внимание то, что таких ioctl-кодов было 13, общее количество ошибок составляет порядка 15-26. 

Небольшой минус данного инструмента состоит в том, что в нем нет возможности применения coverage-guided фаззинга, когда новые тестовые входные данные генерируются так, чтобы обеспечивать максимальное покрытие кода. Подобные варианты возможны, однако для этого надо применять более сложные для развертывания инструменты на основе qemu, которые я пока еще не тестировал. 
